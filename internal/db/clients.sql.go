// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: clients.sql

package db

import (
	"context"
	"database/sql"
	"time"
)

const deleteClient = `-- name: DeleteClient :exec
UPDATE client 
SET deleted_at = CURRENT_TIMESTAMP 
WHERE id = ? AND deleted_at IS NULL
`

func (q *Queries) DeleteClient(ctx context.Context, id int64) error {
	_, err := q.db.ExecContext(ctx, deleteClient, id)
	return err
}

const getAllClients = `-- name: GetAllClients :many
SELECT id, name, email, phone, address1, address2, address3, city, state, zip_code, hourly_rate, notes, additional_info, additional_info2, bill_to, include_address_on_invoice, invoice_cc_email, invoice_cc_description, university_affiliation, updated_at, created_at, deleted_at 
FROM client 
WHERE deleted_at IS NULL
ORDER BY updated_at DESC
`

type GetAllClientsRow struct {
	ID                      int64          `json:"id"`
	Name                    string         `json:"name"`
	Email                   string         `json:"email"`
	Phone                   sql.NullString `json:"phone"`
	Address1                sql.NullString `json:"address1"`
	Address2                sql.NullString `json:"address2"`
	Address3                sql.NullString `json:"address3"`
	City                    sql.NullString `json:"city"`
	State                   sql.NullString `json:"state"`
	ZipCode                 sql.NullString `json:"zip_code"`
	HourlyRate              float64        `json:"hourly_rate"`
	Notes                   sql.NullString `json:"notes"`
	AdditionalInfo          sql.NullString `json:"additional_info"`
	AdditionalInfo2         sql.NullString `json:"additional_info2"`
	BillTo                  sql.NullString `json:"bill_to"`
	IncludeAddressOnInvoice bool           `json:"include_address_on_invoice"`
	InvoiceCcEmail          sql.NullString `json:"invoice_cc_email"`
	InvoiceCcDescription    sql.NullString `json:"invoice_cc_description"`
	UniversityAffiliation   sql.NullString `json:"university_affiliation"`
	UpdatedAt               time.Time      `json:"updated_at"`
	CreatedAt               time.Time      `json:"created_at"`
	DeletedAt               interface{}    `json:"deleted_at"`
}

func (q *Queries) GetAllClients(ctx context.Context) ([]GetAllClientsRow, error) {
	rows, err := q.db.QueryContext(ctx, getAllClients)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetAllClientsRow{}
	for rows.Next() {
		var i GetAllClientsRow
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Email,
			&i.Phone,
			&i.Address1,
			&i.Address2,
			&i.Address3,
			&i.City,
			&i.State,
			&i.ZipCode,
			&i.HourlyRate,
			&i.Notes,
			&i.AdditionalInfo,
			&i.AdditionalInfo2,
			&i.BillTo,
			&i.IncludeAddressOnInvoice,
			&i.InvoiceCcEmail,
			&i.InvoiceCcDescription,
			&i.UniversityAffiliation,
			&i.UpdatedAt,
			&i.CreatedAt,
			&i.DeletedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getClient = `-- name: GetClient :one
SELECT id, name, email, phone, address1, address2, address3, city, state, zip_code, hourly_rate, notes, additional_info, additional_info2, bill_to, include_address_on_invoice, invoice_cc_email, invoice_cc_description, university_affiliation, updated_at, created_at, deleted_at 
FROM client 
WHERE id = ? AND deleted_at IS NULL
`

type GetClientRow struct {
	ID                      int64          `json:"id"`
	Name                    string         `json:"name"`
	Email                   string         `json:"email"`
	Phone                   sql.NullString `json:"phone"`
	Address1                sql.NullString `json:"address1"`
	Address2                sql.NullString `json:"address2"`
	Address3                sql.NullString `json:"address3"`
	City                    sql.NullString `json:"city"`
	State                   sql.NullString `json:"state"`
	ZipCode                 sql.NullString `json:"zip_code"`
	HourlyRate              float64        `json:"hourly_rate"`
	Notes                   sql.NullString `json:"notes"`
	AdditionalInfo          sql.NullString `json:"additional_info"`
	AdditionalInfo2         sql.NullString `json:"additional_info2"`
	BillTo                  sql.NullString `json:"bill_to"`
	IncludeAddressOnInvoice bool           `json:"include_address_on_invoice"`
	InvoiceCcEmail          sql.NullString `json:"invoice_cc_email"`
	InvoiceCcDescription    sql.NullString `json:"invoice_cc_description"`
	UniversityAffiliation   sql.NullString `json:"university_affiliation"`
	UpdatedAt               time.Time      `json:"updated_at"`
	CreatedAt               time.Time      `json:"created_at"`
	DeletedAt               interface{}    `json:"deleted_at"`
}

func (q *Queries) GetClient(ctx context.Context, id int64) (GetClientRow, error) {
	row := q.db.QueryRowContext(ctx, getClient, id)
	var i GetClientRow
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Email,
		&i.Phone,
		&i.Address1,
		&i.Address2,
		&i.Address3,
		&i.City,
		&i.State,
		&i.ZipCode,
		&i.HourlyRate,
		&i.Notes,
		&i.AdditionalInfo,
		&i.AdditionalInfo2,
		&i.BillTo,
		&i.IncludeAddressOnInvoice,
		&i.InvoiceCcEmail,
		&i.InvoiceCcDescription,
		&i.UniversityAffiliation,
		&i.UpdatedAt,
		&i.CreatedAt,
		&i.DeletedAt,
	)
	return i, err
}

const getClientsCount = `-- name: GetClientsCount :one
SELECT COUNT(*) 
FROM client 
WHERE deleted_at IS NULL
`

func (q *Queries) GetClientsCount(ctx context.Context) (int64, error) {
	row := q.db.QueryRowContext(ctx, getClientsCount)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const getClientsWithPagination = `-- name: GetClientsWithPagination :many
SELECT id, name, email, phone, address1, address2, address3, city, state, zip_code, hourly_rate, notes, additional_info, additional_info2, bill_to, include_address_on_invoice, invoice_cc_email, invoice_cc_description, university_affiliation, updated_at, created_at, deleted_at 
FROM client 
WHERE deleted_at IS NULL
ORDER BY updated_at DESC
LIMIT ? OFFSET ?
`

type GetClientsWithPaginationParams struct {
	Limit  int64 `json:"limit"`
	Offset int64 `json:"offset"`
}

type GetClientsWithPaginationRow struct {
	ID                      int64          `json:"id"`
	Name                    string         `json:"name"`
	Email                   string         `json:"email"`
	Phone                   sql.NullString `json:"phone"`
	Address1                sql.NullString `json:"address1"`
	Address2                sql.NullString `json:"address2"`
	Address3                sql.NullString `json:"address3"`
	City                    sql.NullString `json:"city"`
	State                   sql.NullString `json:"state"`
	ZipCode                 sql.NullString `json:"zip_code"`
	HourlyRate              float64        `json:"hourly_rate"`
	Notes                   sql.NullString `json:"notes"`
	AdditionalInfo          sql.NullString `json:"additional_info"`
	AdditionalInfo2         sql.NullString `json:"additional_info2"`
	BillTo                  sql.NullString `json:"bill_to"`
	IncludeAddressOnInvoice bool           `json:"include_address_on_invoice"`
	InvoiceCcEmail          sql.NullString `json:"invoice_cc_email"`
	InvoiceCcDescription    sql.NullString `json:"invoice_cc_description"`
	UniversityAffiliation   sql.NullString `json:"university_affiliation"`
	UpdatedAt               time.Time      `json:"updated_at"`
	CreatedAt               time.Time      `json:"created_at"`
	DeletedAt               interface{}    `json:"deleted_at"`
}

func (q *Queries) GetClientsWithPagination(ctx context.Context, arg GetClientsWithPaginationParams) ([]GetClientsWithPaginationRow, error) {
	rows, err := q.db.QueryContext(ctx, getClientsWithPagination, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetClientsWithPaginationRow{}
	for rows.Next() {
		var i GetClientsWithPaginationRow
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Email,
			&i.Phone,
			&i.Address1,
			&i.Address2,
			&i.Address3,
			&i.City,
			&i.State,
			&i.ZipCode,
			&i.HourlyRate,
			&i.Notes,
			&i.AdditionalInfo,
			&i.AdditionalInfo2,
			&i.BillTo,
			&i.IncludeAddressOnInvoice,
			&i.InvoiceCcEmail,
			&i.InvoiceCcDescription,
			&i.UniversityAffiliation,
			&i.UpdatedAt,
			&i.CreatedAt,
			&i.DeletedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const insertClient = `-- name: InsertClient :execlastid
INSERT INTO client (name, email, phone, address1, address2, address3, city, state, zip_code, hourly_rate, notes, additional_info, additional_info2, bill_to, include_address_on_invoice, invoice_cc_email, invoice_cc_description, university_affiliation) 
VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)
`

type InsertClientParams struct {
	Name                    string         `json:"name"`
	Email                   string         `json:"email"`
	Phone                   sql.NullString `json:"phone"`
	Address1                sql.NullString `json:"address1"`
	Address2                sql.NullString `json:"address2"`
	Address3                sql.NullString `json:"address3"`
	City                    sql.NullString `json:"city"`
	State                   sql.NullString `json:"state"`
	ZipCode                 sql.NullString `json:"zip_code"`
	HourlyRate              float64        `json:"hourly_rate"`
	Notes                   sql.NullString `json:"notes"`
	AdditionalInfo          sql.NullString `json:"additional_info"`
	AdditionalInfo2         sql.NullString `json:"additional_info2"`
	BillTo                  sql.NullString `json:"bill_to"`
	IncludeAddressOnInvoice bool           `json:"include_address_on_invoice"`
	InvoiceCcEmail          sql.NullString `json:"invoice_cc_email"`
	InvoiceCcDescription    sql.NullString `json:"invoice_cc_description"`
	UniversityAffiliation   sql.NullString `json:"university_affiliation"`
}

func (q *Queries) InsertClient(ctx context.Context, arg InsertClientParams) (int64, error) {
	result, err := q.db.ExecContext(ctx, insertClient,
		arg.Name,
		arg.Email,
		arg.Phone,
		arg.Address1,
		arg.Address2,
		arg.Address3,
		arg.City,
		arg.State,
		arg.ZipCode,
		arg.HourlyRate,
		arg.Notes,
		arg.AdditionalInfo,
		arg.AdditionalInfo2,
		arg.BillTo,
		arg.IncludeAddressOnInvoice,
		arg.InvoiceCcEmail,
		arg.InvoiceCcDescription,
		arg.UniversityAffiliation,
	)
	if err != nil {
		return 0, err
	}
	return result.LastInsertId()
}

const updateClient = `-- name: UpdateClient :exec
UPDATE client 
SET name = ?, email = ?, phone = ?, address1 = ?, address2 = ?, address3 = ?, city = ?, state = ?, zip_code = ?, hourly_rate = ?, notes = ?, additional_info = ?, additional_info2 = ?, bill_to = ?, include_address_on_invoice = ?, invoice_cc_email = ?, invoice_cc_description = ?, university_affiliation = ?, updated_at = CURRENT_TIMESTAMP 
WHERE id = ? AND deleted_at IS NULL
`

type UpdateClientParams struct {
	Name                    string         `json:"name"`
	Email                   string         `json:"email"`
	Phone                   sql.NullString `json:"phone"`
	Address1                sql.NullString `json:"address1"`
	Address2                sql.NullString `json:"address2"`
	Address3                sql.NullString `json:"address3"`
	City                    sql.NullString `json:"city"`
	State                   sql.NullString `json:"state"`
	ZipCode                 sql.NullString `json:"zip_code"`
	HourlyRate              float64        `json:"hourly_rate"`
	Notes                   sql.NullString `json:"notes"`
	AdditionalInfo          sql.NullString `json:"additional_info"`
	AdditionalInfo2         sql.NullString `json:"additional_info2"`
	BillTo                  sql.NullString `json:"bill_to"`
	IncludeAddressOnInvoice bool           `json:"include_address_on_invoice"`
	InvoiceCcEmail          sql.NullString `json:"invoice_cc_email"`
	InvoiceCcDescription    sql.NullString `json:"invoice_cc_description"`
	UniversityAffiliation   sql.NullString `json:"university_affiliation"`
	ID                      int64          `json:"id"`
}

func (q *Queries) UpdateClient(ctx context.Context, arg UpdateClientParams) error {
	_, err := q.db.ExecContext(ctx, updateClient,
		arg.Name,
		arg.Email,
		arg.Phone,
		arg.Address1,
		arg.Address2,
		arg.Address3,
		arg.City,
		arg.State,
		arg.ZipCode,
		arg.HourlyRate,
		arg.Notes,
		arg.AdditionalInfo,
		arg.AdditionalInfo2,
		arg.BillTo,
		arg.IncludeAddressOnInvoice,
		arg.InvoiceCcEmail,
		arg.InvoiceCcDescription,
		arg.UniversityAffiliation,
		arg.ID,
	)
	return err
}
